I've been experimenting with different encodings and I've come up with some new scheme with the ergonomics I mostly like.
It is currently presented in [higher-kinded-java repository](https://github.com/sviperll/higher-kinded-java)

Basically It's a highj encoding, but with existential type twist.
You can get a taste of using it as a library by looking at the
[Main.java source code](https://github.com/sviperll/higher-kinded-java/blob/master/src/main/java/com/github/sviperll/higherkindedjava/Main.java)
.

I propose the way to use higher-kinded types based on some annotation processor.
User code should look like this

````java
@ImplementsGeneratedTypeSupportInterface
public interface List<T> extends GeneratedListTypeSupport<T> {
    // GeneratedListTypeSupport interface is generated by annotation processor
    // no additional code is required to implement GeneratedListTypeSupport

    // Ordinary list definition
}
````

When you implement such generated interface, your class/interface obtain subclass `TypeConstructor` with field `get` and
you can use it like this:

````java
    List.TypeConstructor.Is<?> proof = List.TypeConstructor.get;
````

`List.TypeConstructor.Is` is also generated by annotation processor.
`List.TypeConstructor.Is` object is parametrized by a wildcard-argument.
And this is the major difference from highj. The only way to actually use this object is to capture this wildcard:

````java
    <L> void playWithListType(List.TypeConstructor.Is<L> proof) {
    }

    void run() {
        List.TypeConstructor.Is<?> proof = List.TypeConstructor.get;
        playWithListType(proof);
    }
````

And after you have captured a wildcard you can use `Type.App` objects:

````java
    <L> void playWithListType(List.TypeConstructor.Is<L> proof) {
        Type.App<L, Integer> typeApp = proof.convertToTypeApp(List.of(3));
        List<Integer> list = proof.convertToList(typeApp);
    }

    void run() {
        List.TypeConstructor.Is<?> proof = List.TypeConstructor.get;
        playWithListType(proof);
    }
````

You can't do it without capturing wildcard into some type-variable.

````java
    void run() {
        List.TypeConstructor.Is<?> proof = List.TypeConstructor.get;
        Type.App<?, Integer> typeApp = proof.convertToTypeApp(List.of(3));

        // Compile-time error can't unify two different captured types
        List<Integer> list = proof.convertToList(typeApp);
    }
````

So, basically this captured type variable is a proof that `Type.App` instance is created by the same
type-constructor-is-object and can be safely transformed back into a List.
And you can't do anything without capturing since `List.TypeConstructor.get` field is actually parametrized with wildcard-type-argument.

Having this framework at your disposal it's easy to get your
[Monads](https://github.com/sviperll/higher-kinded-java/blob/master/src/main/java/com/github/sviperll/higherkindedjava/Monad.java)
with type-safe implementations (
[List](https://github.com/sviperll/higher-kinded-java/blob/master/src/main/java/com/github/sviperll/higherkindedjava/data/ListMonad.java)
,
[Optional](https://github.com/sviperll/higher-kinded-java/blob/master/src/main/java/com/github/sviperll/higherkindedjava/data/OptionalMonad.java)
)

Rawtypes, manual instantiation of `Type.App` interface and plain old casts
can all circumvernt type-safety and cause ClassCastException
But all these features are expected to be inherently unsafe.

Manual instantiation of `Type.App` interface can be made visibly unsafe
we can add method like

````java
    void pleaseDoNotImplementMeItIsUnsafe();
````

to make it obviously and visibly unsafe.

The remaining piece of a puzzle is an annotation processor to actually generate required code,
but looking at
[code that is supposed to be generated](https://github.com/sviperll/higher-kinded-java/blob/master/src/main/java/com/github/sviperll/higherkindedjava/data/GeneratedOptionalTypeSupport.java)
it seems not so difficult to implement.
